---
layout:      post
title:      「HUAWEI」OSPFv2原理概述
subtile:	"有些基础方面还没有写的很清除，欢迎指导补充"
date:        2021-01-26
author:      Zhy
header-style: text
catalog: true 
tags:
    - 华为
    - OSPF
---



# 前言

>  也不是几岁屁孩了，OSPF的前言还要我多说啥吗？OSPF和ISIS一样都是链路状态协议，OSPF和ISIS是有着共同之处的。他们传递的都是自身特殊格式而形成的链路状态信息，这不能被ACL所抓取到，他们都是有区域划分，都有虚节点。OSPF主要搞清楚他6个LSA，邻居状态过程，基本上就OK了，不难的。
>
>  本章节是先讲总共握手及邻居邻接建立，再到各类LSA的详细解说过程，注意LSA我是分开场景讲的，实际中各类LSA也是根据自身区域情况而产生，10.0是补充章节。第八章及以后文章还待补充完善。

# 1、邻接建立及握手过程

## 1.1 概述

待补充

## 1.2 OSPF报文头部

OSPF封装于IP层，协议号89。OSPF分为五个报文：HELLO、DD、LSR、LSU和LSAck。五种报文具有相同的报文头格式，长度为24字节。

![OSFP报文头部](https://s3.ax1x.com/2021/01/26/sjQF2T.png)

<center>图：OSPF报文头部</center>

OSPF头部长度24 Byte，字段讲解如下：

| 字段            | 含义                                             |
| --------------- | ------------------------------------------------ |
| version         | 版本号，目前OSPF版本号为2                        |
| Message Type    | 消息类型，Hello为1，DD为2，LSR为3，LSU为4 LSA为5 |
| Packet Leng     | OSPF长度，包括OSPF头部字段                       |
| Sou OSPF Route  | 发送报文的OSPF路由器标识                         |
| Area            | 区域ID                                           |
| Check           | 校验和                                           |
| Authe Type/Data | 认证类型和认证数据                               |



## 1.3 网络类型及不同类型间建立邻居

OSPF接口根据链路类型可分成四种网络类型：

- Point-to-point networks：当链路层协议为PPP、HDLC和帧中继（仅P2P类型子接口）时。缺省OSPF认为是P2P点到点网络

- broadcast networks：当链路层协议为Ethernet时。缺省OSPF认为是Broadcast广播网络

- NotBroadcast Multi-Access Networks：当链路层协议为帧中继和ATM时。缺省OSPF认为是NMBA

- Point-to-Multipoint networks：无缺省认为，只会被强制修改成该类型。常见为将非全连通的NMBA修改成P2MP形式

  不同的网络类型，可使OSPF按不同的方式来工作，具体如下：



| 网络类型 | 报文的发送                                 |
| -------- | ------------------------------------------ |
| 广播类型 | 组播发送HELLO、LSU和LSAck，单播发送DD和LSR |
| P2MP     | 组播发送HELLO，单播发送其他                |
| NMBA     | 全单播                                     |
| P2P      | 全组播                                     |

**说明：**LSAck报文在做回应时，对于接收到的LSU报文，若LSU报文为单播，则单播回复，LSU为组播，则组播回复。且采用组播回复时，若自身为DRother，那么目的地址为224.0.0.6。为DR和BDR或点到点类型网络，则为224.0.0.5。

不同的接口网络类型的邻居间时可以正常建立邻居关系的，但需要注意的时Hello/Dead时间需要相同。具体不同邻居之间的建立，如下所示：

| 网络类型      | 邻居关系           | 邻接 | 路由计算           |
| ------------- | ------------------ | ---- | ------------------ |
| NMBA+其他类型 | 不可以             | -    | -                  |
| P2MP+广播     | 调整时间间隔后可以 | 可以 | 无法计算出对方路由 |
| P2MP+P2P      | 可以               | 可以 | 可以               |
| P2P+广播      | 可以               | 可以 | 无法计算出对方路由 |

**说明：**P2P和P2MP对广播可以建立邻接关系，可以进行LSDB数据库同步，但是在路由的计算上无法形成，这是由于画逻辑拓扑时，广播类型需要连接到虚节点，但P2P网络需要和邻居节点直连，所以在逻辑拓扑上，二者无法连接到一起，这就导致了计算路由时，互相都无法计算出各自节点后面的路由。



## 1.4 邻居建立过程

OSPF通过hello报文来发现和维护邻居关系，邻居关系不同于邻接，邻居给关系是指达到2-way状态，在2way状态之后，是邻接关系。

hello报文在不同的网络类型的接口上，发送间隔与目的地址不同。

- 在广播和点到点网路中，hello是每10秒发送一次，在NMBA和P2MP中，每30秒发送一次。dead时间为4倍的hello时间
- 在广播、P2P和P2MP中，OSPF通过组播的HELLO自动发现邻居，目的地址是224.0.0.5（所有OSPF路由器）而在NBMA网络中，需要手工指定邻居。

说明：目前网络大多都是以太网，也就是网络类型为Broadcast，而PPP/HDLC/帧中继，P2P子接口则被看成P2P类型网络。非广播的帧中继。X.25和ATM等可以配置成NBMA和P2MP网络类型。



在建立邻居关系是时，双方路由器互相发送HELLO报文，以下参数必须匹配才能够形成邻居，否则丢弃。

1. hello/dead时间一致
2. 直连路由器Router-ID无冲突
3. 区域ID一致
4. 区域类型相同 (options字段相同)
5. 认证类型和密钥一致

![OSPF_HELLO报文](https://s3.ax1x.com/2021/01/26/sjMvrQ.md.png)

<center>
    图：Hello报文
</center>





OSPF共有八种状态，分别是：Down、Attempt、Init、2-Way、Exstat、Exchange、Loading和Full。

邻居关系的建立是为了保证OSPF路由器间的双向邻居成功建立。邻居关系的状态由Down到Attmpt到Init到2-WAY

1. Down，邻居会话初始阶段，邻居的RID未存在自身的邻居列表里。

2. Attmpt，NBMA中存在，表明对端在邻居失效时间超时后仍然没有回复hello。此时依旧向对端发送hello

3. Init，收到邻居发来的hello且该hello中的**Active Nei字段未包含自身路由器的R-ID**，则将邻居状态置位INIT

4. 2-WAY，再次收到邻居发来的hello且hello中的**Active Nei字段中包含自身的R-ID**，则将邻居状态置位2-WAY

   此时开始就是邻接状态了，需要注意的是，在广播和非广播中，邻接关系在DR/BRR选择完成之后。



**Router-ID建立过程：**

每台OSPF路由器都需要配置一个Router-ID来标识自身，Router-id有以下方法形成

1、手工配置Router-ID

2、自动选择设备中活跃的最大地址的环回接口，若不存在环回接口，则选择活跃物理接口中地址最大的。



  





## 1.5 邻接建立过程

邻接关系的建立是邻居路由器间为完成同步而发生的LSA交互过程，也是邻居路由器间初次通告LSA，快速同步的过程。同步完成后，最终是FULL状态。邻接关系的状态由Exstart到Exchange到Loading到FULL最终状态。

**说明：**广播和非广播情况下（即需要选择DR/BDR的情况下）Drother之间会一致保持在2-WAY状态，Drother同DR/BDR是FULL状态。

![OSPF_空DD](https://s3.ax1x.com/2021/01/26/sjQPP0.png)



**信息交换初始状态ExStart：**在该状态下，本地和邻居路由器互传空DD报文。ExStart作用：

- 确定主从关系
- 确定DD的初始序列号
- 比较接口MTU（可选）



在该状态下，路由器互相发送空DD报文中 I(Initalize），M（More）及MS（Master/Salve）位。

- I位，初始化位，仅头两份DD报文中置位，代表同步过程开始。
- M位，More更多，如果M=0，则代表后续DD报文中无LSA Summary要传递。任何一方M位不置为0，Master就要继续发送DD报文，Slave收到之后，不论是否还有LSA Summary要传递，都要回应DD报文。

初始双方都认为自身是Master，所有M/S均置位，双方收到对方的DD报文，RID高者成为Master，此后过程中,M/S会一直置位，Master会一直发送DD报文，Slave一直会回应DD报文，Slave回应的DD报文是对Master发送的DD报文的确认。此过程持续到双方的LSA头部交换完成。

**说明：**由于Exstart未开启MTU比较，所以报文中的MTU值默认为0，即不比较。



**信息交换状态ExChange：**

选举完Master后，Slave路由器主动向Master回送DD报文，其中包含LSDB的LSA头（LSA Summary）列表，Slave发送的DD中，Seq序列号采用Master发过来时的序列号。Master也会把自身的头列表用DD发送，同时Seq+1，Slave设备收到了，会用相同序列号，来做回应。

任何一侧只要还有未传递完的LSA 头，M位就还是置位，Master就一定会产生DD报文来让Slave回应

Slave：选举完Master后，Slave主动向Master会送DD报文，Seq采用Master相同的

Master：每次发DD都会seq+1，根据收到的DD是否和自己发送的DDseq相同来判断是否DD回送正常



此时LSDB同步完成后，将会进入Loading状态，并且收到DD的路由器会和自己的链路状态数据库作对比，确定需要哪些LSA的完整信息，就会发送LSR请求给邻居。

**信息加载状态Loading：**在这一状态下，本地路由器会继续向它的邻居路由器发送链路状态请求数据包LSR，以请求本地LSDB中没有的完整的LSA。收到LSR的报文，路由器会用包含完整的被请求的LSA的LSU做回应。

请求方收到LSU后，如果无误，则采用LSAck确认该LSU。一份LSAck可同时为多份LSU做确认。所有确认的都完成，就进入FULL状态，至此，LSA同步过程完毕，邻居状态成为FULL









总结：

1、Down：邻居会话的初始阶段，

2、Attempt：该状态仅在NBMA网络中，表明对端在邻居失效时间超时后，仍然没有回复Hello。此时依旧轮询向对端发送hello

3、Init：收到Hello报文后状态为Init。

4、2-way：**收到的Hello报文中包含有自己的R-ID，则状态为2-way。**如果不形成邻接关系则邻居状态机停留此阶段。此阶段将会根据R-ID选举DR。

5、如果形成邻居关系，则从Init状态转到Exstart状态，开始协商主从关系，并确认DD序列号。

6、Exchange：主从关系协商完毕后 开始交互DD。DD交互完成后，双方请求自身LSDB中缺少的完整LSA，通过LSR发送

7、Loading：DD报文交互完成，即成为Loading状态。

8、Full：LSR重传列表为空，此时状态为FULL。

网络启动了之后，双方OSPF路由器互相发送HELO报文，此时收到对方的HELLO后，进入INIT状态，此时的











## 1.6 DR/BDR及组播组地址

在OSPF中，网络类型为广播MA和NMBA网络下需要选举DR/BDR，DR/BDR的选举是在2-WAY邻居关系建立完成之后的。Drother之间的邻居关系将会一直保持2-way状态。**DR/BDR/Drother选举过程如下：**

1. 网络中所有启用了OSPF的接口且OSPF接口优先级不为0的路由器默认成为Drother角色
2. 所有DRother路由器中，当网络中不存在BDR时，则优先级最大的成为BDR。
3. 当网络内不存在DR时，则BDR自动成为DR。此时BDR则为空，再从所有Drother中选举出BDR。

DR/BDR的选举是为了MA或NMBA网络中发送二类LSA，来描绘网络下的虚节点周边连接关系。

**说明：**DR/BDR的比较为，优先比较接口优先级，相同后比较OSPF路由器Router-ID。需要说明的是接口优先级默认为1，范围为0到255，若接口优先级配置为0，则代表不参与选举。





OSPF采用两个组播组地址：224.0.0.5和224.0.0.6。（点到点网络仅使用224.0.0.5）

- DR和BDR发送LSU和LSAck及广播网络中的所有路由器发送HELLO均采用224.0.0.5
- DRother路由器发送LSU和LSAck采用224.0.0.6.DR和BDR将持续监听该组播组地址。
- 当DR/BDR向Drother发送HELLO、LSU和LSR时，目的地址为ALL Router



**All DRouters**(224.0.0.6) 

**All OSPF路由器** (224.0.0.5)

**说明：**LSAck报文在做回应时，对于接收到的LSU报文，若LSU报文为单播，则单播回复，LSU为组播，则组播回复。且采用组播回复时，若自身为DRother，那么目的地址为224.0.0.6。为DR和BDR或点到点类型网络，则为224.0.0.5。



## 1.7 报文字段总结

这么一个章节，就是怕报文字段中的参数，被遗忘了... 邻居状态机我就不说了，就是发的5个报文，hello dd，LSA ck等等，和1~5，7类字段的参数解读。

### 1.6.1 五种信息报文

### 1.6.2 6个LSA



3.4 OSPF的有向图绘画

两种有向图，分别是Link类型P2P和TransNet



省略展示。

Link-Stale-ID 

  对于Router-LSA（Type1），表示自己的Router-ID

  对于Network-LSA（Type2），表示DR的IP地址

  对于Summery-LSA（Type3），表示路由前缀

  对于ASBR-Summery-LSA（Type4），表示ASBR的Router-ID

  对于ASE（Type5），表示路由前缀



**1.6.1.2、 二类Network LSA**

![1.6.2.2](https://s3.ax1x.com/2021/01/26/sjMOxS.png)

<center>
    图：OSPF的二类报文
</center>

红色部分表明了这个MA网络中，所有连接DR的BDR和Drother路由器ID

```
四台路由器中，也就是说处于同一个MA网络中的所有路由器设备的二类LSA都是一样的，二类LSA在MA网络中由DR发送。LS id标明了DR的R-ID，Adv标明了DR的出接口IP地址
```





----

### 1.6.3 有关Ls id

  对于Router-LSA（Type1），表示自身R-ID

  对于Network-LSA（Type2），采用DR路由器的出接口IP地址

  对于Summery-LSA（Type3），表示路由前缀

  对于ASBR-Summery-LSA（Type4），表示ASBR的Router-ID

  对于ASE（Type5），表示路由前缀

### 1.6.4 Options

```
关于Options字段：共有DN，O，DC，L，N&P，MC，E，MT
见的多的：DN，O,N&P,E。
--------------------见的多的--------------------
1）DN：MPLS VPN中，当PE引入了BGP路由，向CE发布3,5,7类时。此时会置位。防止另一端PE又从CE学到这条LSA而引发环路。
2）O：v3中用到，当始发路由器支持9、10、11时。O值位。
3）N&P：N位仅hello用，当始发路由器支持7类时，N置位。N值不匹配的邻居无法成立
P位仅在七类头部使用，该位以告知NSSA ARB将7转五。由于特殊原因，N和P共享一个位。
4）E：当始发路由器能够接收外部LSA时，E（外部路由能力）位值位
E功能在骨干和非Stub中，为1；Stub区域中将被设置为0。NSSA是特殊的Stub。该位用于hello中，指示接口作为外部LSA发送和接收Type5的能力。E值不匹配的邻居无法建立

--------------------见的不多--------------------

DC位：表明是否有能力支持对按虚链路的拓展性，值位的路由器表明仅代表它能够正常处理DNA LSA。并不代-表此设备为按虚链路的端设备。
L位：表明OSPF数据包是否包含链路本地信令LLS模块。仅在hello和DBD中值位。

MC：但始发路由器支持M-OSPF时值位。思科配置M-OSPF会出现错误，华为不清楚。
MT：
```



# 2、LSA泛洪行为



泛洪是个可靠的过程，通过LS Update和LS Ack来进行，确认机制包括显式和隐式确认，接口收到泛洪的LSA报文（即LSU，LSU里面包含了很多LSA头部）,会继续向其他接口泛洪。当一份LSA被泛洪出去，当前路由器会记录在该接口的所有邻居数量，并为之维护重传列表，没有收到 显式or隐式确认的LSA会在5s后单播重传更新（与网络类型无关）。



OSPF的报文确认机制

- 显式确认

  显式确认为收到邻居发送的报文，使用独立的其他报文给他做确认，

  例如发送LSR，回复LSU；例如发送LSU，回复LSAck

- 隐式确认

  隐式确认为使用相同报文做应答确认

  例如HELLO报文中采用Avtive Nei字段（收到邻居的HELLO即在Avtive Nei字段添加邻居的R-ID，并回送邻居）

  例如DD报文中Slave采用Master路由器发送过来的报文序列号做会用。DD报文除了第一份DD和Slave应答Master的最后一份DD外，其于DD报文还包含LSA摘要信息，即做应答又做确认。不用使用独立报文做回应。





![OSPF_泛洪确认](https://s3.ax1x.com/2021/01/26/sjQ95q.md.png)

192.168.1.2向所有Drother发送LSU更新报文，随后192.168.1.1向192.168.1.2发送LSR的显式确认

**说明：**LSAck报文在做回应时，对于接收到的LSU报文，若LSU报文为单播，则单播回复，LSU为组播，则组播回复。且采用组播回复时，若自身为DRother，那么目的地址为224.0.0.6。为DR和BDR或点到点类型网络，则为224.0.0.5。





**路由器的泛洪行为**

1. 一个接口收到LSA，存放到LSDB后，再从“其他接口”重新泛洪出去，泛洪也有“水平分割行为”。即，从接口收到LSA，不会再泛洪给该接口（例外是DR会把从一个DRother收到的LSA，通过原接口重新通告给其他DRother路由器。
2. 重新通告的LSA和收到的LSA除Age+1外，其他内容一致，如Checksum等
3. LSA会泛洪到域边界（然后域边界的话，你泛洪1或2，他就为每条OSPF路由，各产生3类 并向其他域通告）
4. 每台路由器收到LSA，会进行判断，先判断LSDB中是否存在该LSA，没有则存储，有则忽略。
5. 如果接收时没有判断LSDB是否存在该LSA，或路由器没有停止转发，则会致LSA在区域内无休止传递。



**标识LSA唯一性**

有趣的是，路由器会周期性更新同一份LSA，那么如何判断这份LSA的唯一性呢？

每份LSA通过三要素来标识自己的唯一性：LSA Type、Link State ID和通告者Advertising Router-ID

**例：**R1产生的LSA1，他的类型为RouterLSA，LinkState为1.1.1.1，通告路由器1.1.1.1





**判断LSA的新旧**

当一台路由器收到如下的三个要素相同的LSA时，我们就认为是收到了一个LSA的多个相同实例

- LSA TYPELSA类型

- Link State ID链路状态ID

- Advertising Router-ID通告者路由器ID

  例如：R1(1.1.1.1地址)产生了一份LSA 1，则他的LSA Type=RouterLSA。LinkState=1.1.1.1；Adverti Router=1.1.1.1

  

判断相同ID的新LSA要依次比较如下内容：LSA序列号、LSA报文校验和、LSA生成时间。

- **序列号（sequence）**：周期性（30min）产生新的LSA，每次产生的LSA序列号都会增加1，序列号越大代表其越新，序列号从0x80000001到0x7FFFFFFF。

- **报文校验和（checksum）：**当序列号相同时比较校验和，校验和值越大，该LSA实例越新；校验和计算除了Age以外的其他字段，且存在放LSDB时，路由器会5min重新计算依次校验和的值。

- **生存时间（LS Age）：**最大时间Max Age为3600秒，LSA在泛洪器间每经过一跳路由器或存放进入LSDB时Age增加1。若Age到达Max Age，路由器会从LSDB清除该LSA。

  若LSA间Age差额超过15min（900s）则Age小的LSA被认为更“ 新”。若Age差额小于15min，则二者视为相同新，那么仅保留先收到的一份。




如果收到的LSA在本地LSDB中没有，则接收该LSA并继续泛洪

如果收到的LSA在本地LSDB中存在，但收到的LSA比本地LSDB更“新”，则更新LSDB并泛洪新的LSA。

如果收到的LSA比本地LSDB中的更旧，则不接收该LSA。

如果收到的LSA和本地LSDB中的一样新，则忽略并终止泛洪。

如果收到的LSA损坏，比如校验和错误，则不接收该LSA。







**说明：**

- 泛洪是可靠的、周期性（30min）或触发产生的LSA通告过程。
- 泛洪是把LSA向区域中的每条链路复制并通告的过程。
- 全区域的泛洪会导致路由器收到多份相同的LSA，LSDB根据如下规则来保留最新的。
- 路由器仅泛洪最新的LSA，相同ID的旧的LSA会被新的LSA所覆盖。
- 一旦所有新的LSA被所有路由器收到，泛洪就结束了。





# 3、LSA 1&2类分析



**Router-LSA报文信息** 一类所有变种都在这了

![OSPF_一类字段](https://s3.ax1x.com/2021/01/26/sjQiGV.md.png)

```
LS Age：16位，后15位数用来表示age，LSA初始产生时，age数值为0。最高位赋有特殊含义，置位表示该LSA在LSDB中永不老化
Options：发个图出来我。
Link State ID：路由器R-ID ###一类中的LSA，RID和产生RID都相同，三类中路由RID是边界ABR RID。
Adv Rtr：产生该LSA的路由器R-ID
Seq num：线性序列号，从0x80000001开始递增，新的LSA序列号会增加，标明了这个LSA的新旧程度。
Check  ：校验和，对整个LSA除了age域做校验。
Length ：表示该LSA的长度，单位字节。Byte
Flags：
	V：表明是否虚链路
	E：是否ASBR
	B：是否ABE
Num Links：Link的数量，代表OSPF画出的有向图上的Link数量，而非物理路由器接口数量。
	Links：OSPF定义了四种Link，接口的网络类型不同，那么产生的Link也不同。路由器将自身宣告进OSPF的接口的Link放入其RouterLSA在区域内泛洪。看下文图片。
```

| Type     | Link ID            | Data                               |
| -------- | ------------------ | ---------------------------------- |
| P2P      | 邻居的R ID         | 该网段本地接口IP地址               |
| TransNet | DR的接口IP地址     | 该网段本地接口IP地址               |
| StubNet  | 该Stub网段的IP地址 | 该Stub网段的网络掩码               |
| Vitrual  | 虚链路邻居的RID    | 去往该虚链路邻居对应本地接口IP地址 |

注：MA网络TransNet中，所有路由器发1类，伪节点即DR发二类。P2P中，需要用到2个link，p2p link描绘直连链路，Stub link描绘网络

这里再给出设备中查看数据库的图片，LSA一类，就那么回事儿~

![OSPF_LSDB一类](https://s3.ax1x.com/2021/01/26/sjQSVs.png)



```
关于Options字段：共有DN，O，DC，L，N&P，MC，E，MT
见的多的：DN，O,N&P,E。
--------------------见的多的--------------------
1）DN：MPLS VPN中，当PE引入了BGP路由，像CE发布3,5,7类时。此时会置位。防止另一端PE又从CE学到这条LSA而引发环路。
2）O：v3中用到，当始发路由器支持9、10、11时。O值位。
3）N&P：N位仅hello用，当始发路由器支持7类时，N置位。N值不匹配的邻居无法成立     				P位仅在七类头部使用，该位以告知NSSA ARB将7转五。由于特殊原因，N和P共享一个位。
4）E：当始发路由器能够接收外部LSA时，E（外部路由能力）位值位
E功能在骨干和非Stub中，为1；Stub区域中将被设置为0。NSSA是特殊的Stub。该位用于hello中，指示接口作为外部LSA发送和接收Type5的能力。

注意！E位不匹配不会形成邻居关系哦。这和N一样的
注意！E位不匹配不会形成邻居关系哦。这和N一样的
注意！E位不匹配不会形成邻居关系哦。这和N一样的

--------------------见的不多--------------------

DC位：表明是否有能力支持对按虚链路的拓展性，值位的路由器表明仅代表它能够正常处理DNA LSA。并不代-表此设备为按虚链路的端设备。
L位：表明OSPF数据包是否包含链路本地信令LLS模块。仅在hello和DBD中值位。

MC：但始发路由器支持M-OSPF时值位。思科配置M-OSPF会出现错误，华为不清楚。
MT：
```



---

Network LSA，用来描绘MA网络上的拓扑关系。（2类仅出现BMA或者NMBA网络上，DR除了做数据库同步外，还产生2类LSA，2类LSA用于描绘虚节点周边连接关系。LSA2用DR路由器的接口IP来标识。

![OSPF_二类字段](https://s3.ax1x.com/2021/01/26/sjMxbj.png)

```
Link State ID：采用DR路由器的出接口的IP地址
ADv Router：产生者R-ID
Netmask：和Link Sta ID做“与”计算，得出LSA2所代表的网络号。
Attached Router：列出MA或NMBA上与DR形成完全邻接关系且包括DR本身的所有路由器的RID

根据Link State与Netmask可以计算出LSA2所代表的网络是10.1.1.0/24，并根据Attached描述，得知该网络同时连接三台路由器,2 3 6，LSA2的作用是通告TransNet网络号及描述该网络和路由器的连接关系。
```





# 4、区域结构设计

## 4.1 区域结构及防环设计

**4.1.1 建立区域**

设立区域就要先知道泛洪（上文说到过），一个域内泛洪，那么整个域内都会动荡，都会进行SPF路由计算，如果网络的规模太大（成百上千）那么一次LSA泛洪，将会是颠覆性的灾难。并且OSPF路由器用于存储LSA的LSDB数据库，将会十分的庞大。所以要进行区域划分，为的就是更好的管理以及LSDB数据库不用存储那么大量的信息了，但这也引发了其他的问题，将区域划分成了多个之后，其他区域的路由信息，比如1区域内的路由信息，那我2区域，可能就只有ABR才知道他的存在，有着环路的风险。



**区域特点:**

1. 最大限度地减少路由表条目
2. 本地区域内拓扑变化的影响
3. 在区域边界阻止LSA的泛洪



## 4.2 LSA 3及区域间路由通告



LSA3类的作用是区域间传输，也有防环作用。（通过ABR定义来防环，不允许非ABR设备产生三类，ARB又有定义，仅拥有活跃骨干邻居才算是ABR，不允许非ABR产生LSA3类，

```
1、ABR为区域内的每条OSPF路由各产生一份LSA3类，并向其他区域通告。
2、边界若有多台ABR存在，则每个ABR均产生3类来通告域内路由，LSDB中存在多份LSA3，通过Adver Router字域来区分。
3、区域间传递的是路由，这是因为边界矢量特性
区域内传递的是路由，LSA3是由每个区域的ABR产生，并在该区域内泛洪的。路由进入其他区域后，再由该区域的ABR产生LSA3，并继续泛洪。
4、OSPF在区域边界上具备矢量特性。即：LSA的产生依赖于路由表中相应路由是否存在。
5、计算路由时，路由器计算自己区域内到ABR的成本COST，在加上LSA3传递的区域间COST（即ABR到达该三类路由的COST），得到的就是自身到达该三类网络的端到端cost。
6、如果ABR上路由表中的某条OSPF路由不在可达，则ABR会立即产生一份Age为3600秒的3类向域内泛洪，用于在区域内撤销该网络。
```

OSPF区域间是通过3类来交互路由信息的，三类不包含拓扑信息。

```
Type	:Sum-Net       #Type 3
Ls id	:10.1.2.0		#路由前缀 即网络号
Adv tr  :2.2.2.2		#ABR的R-ID 产生该三类的R-ID
LS age  :1683			LS老化时间
Len		:28
Options :E				#仅E-bit置位，具体可以看1.6.4 Options
seq#	:800000001		
chksum	:0x5cb3
Net mask:255.255.255.0  #路由掩码
Tos 0 metric:100			#ARB到目标网络的最小开销，自身仅计算到达ABR开销，两者相结合 就是端到端开销
Priority : Low
```



## 4.3 真伪ABR定义及路由通告

 **真伪ABR定义**

ABR定义：ABR处于区域边界间，限制LSA泛洪的范围。但只有真ABR才会进行路由通告

ABR上有如下规则：

1. 通过ABR1进入非骨干区域的的三类路由，若ABR2在骨干区域有OSPF，则该三类路由不可进入ABR2的路由表。此处ABR1和2是处在骨干区域和普通区域的边界ABR设备。
2. 若ABR2在骨干区域没有邻居，仅有一个网络出现在骨干区域，则ABR1所通告的三类路由可以进入其路由表；
3. 没有出现在ABR路由表的路由 是不会被通告到其他区域的，这是边界上的矢量特性（可以看7.2章节）

上述规则，适用于3/4类，不适用于五类。

**真正意义上的ARB，是拥有活跃骨干区域的邻居。如果仅拥有区域0接口，但不拥有邻居，那么他不算是真正的ABR，也就不能转发三类路由**

## 4.4 区域分类及Stub

###  4.4.1 Area分类

区域的划分有着：普通区域，骨干区域，Stub和NSSA区域。骨干区域就一个 Area0，其他区域需要连接着骨干区域。普通区域即是区域号非0的，是最统用的区域。

- Stub区域又叫末梢区域，他的异变Totally Stub叫完全末梢区域。
- NSSA区域又叫非纯末梢区域，他的异变Totaly NSSA叫完全非纯末梢区域。

Stub区域是一种特殊的区域，区域内仅发布LSA 1/2/3，访问OSPF外部网络仅通过ABR实现。没有ASBR无法引入其他协议路由，仅ABR。

完全Stub，在Stub的基础上，过滤了LSA 3的发布，仅0.0.0.0 LSA3可以传递，例如骨干区域的网络进来，是发LSA 3 192.168.1.0 但开启了Totally Stub，那么仅发一条0.0.0.0的LSA 3，并且是ABR发送。

NSSA区域是Stub的升级，在Stub的基础之上取消了不能引入其他协议路由的限制，NSSA也就拥有了ASBR，但要注意的是，NSSA 不支持5类LSA,Why？因为NSSA可以引入外部路由。但是这个外部路由可能需要限制在自己的区域内传播，所以不能生成5类lsa，因为5类lsa的传播范围是整个ospf域。如果一定要传播到其它区域，就需要ABR做七/五转换，把7类lsa转换成5类lsa，再传播出去。NSSA区域内的外部路由，仅能以7类lsa的形式存在。

完全NSSA，在NSSA基础上，过滤了LSA 3的发布，仅0.0.0.0 LSA3可以传递，例如骨干区域的网络进来，是发LSA 3 192.168.1.0 但开启了Totally Stub，那么仅发一条0.0.0.0的LSA 3，并且是ABR发送。

|               | Stub                       | To St                    | NSSA                                        | To NS                      |
| ------------- | -------------------------- | ------------------------ | ------------------------------------------- | -------------------------- |
| 区域中LSA类型 | LSA1/2/3 ABR产生3类0.0.0.0 | 1/2类，ABR产生3类0.0.0.0 | 1/2/3/7， A(S)BR产生LSA 7(0.0.0.0)          | 1/2/7 A(S)BR产生7类0.0.0.0 |
| ABR/ASBR      | 区域内不允许ASBR           | 同STUB                   | 区域内允许部署ASBR，边界设备即使ABR也是ASBR | 同NSSA                     |
| 配置          | area stub                  | area stub no-sum         | area nssa                                   | area nssa no-sum           |

**注意：**Hello报文中，Stub区域的E-bit 不置位（就没有了）异变情况也一样。NSSA区域仅N-Bit置位。E-bit没置位的，是不会接受E-bit值位的Hello包的，一定要E比特值位相同的邻居，才会建立邻居关系，NSSA就是N比特置位，才会建立邻居。



---



### 4.4.2 Stub区域

Stub大概的内容，其实都在上述部分了，但要说明一些

- 骨干区域不能配置Stub区域（NSSA也不能）
- 区域内所有路由都要配置成Stub属性才可以。
- Stub中不存在ASBR，因为STUB不产生五类。
- 虚链路无法穿越Stub。

为了外部路由可达，ABR会产生LSA 3（0.0.0.0）默认路由通告给Stub区域内其他非ABR的邻居。完全Stub就是限制了普通路由器产生LSA 3类，开启了完全功能的Stub，那么仅ABR可发送 默认的三类。

配置命令：

```
[AR4]ospf 1
[AR4-ospf-1]area 1
[AR4-ospf-1-area-0.0.0.1]stub 配置Stub区域
[AR4-ospf-1-area-0.0.0.1]stub no-summary 配置成Totally Stub区域
```



---



###  4.4.3 NSSA区域

NSSA区域和Stub区域有着相识的地方，他们二者都不传播来自OSPF网络其他区域的外部路由。二者差别在于：Stub中不能引入外部路由,NSSA能够将外部路由引入并传播到整个OSPF当中。

NSSA的默认路由并不是3类，而是7类0.0.0.0默认路由。

- 骨干区域不能配置成NSSA区域
- 区域内所有路由都要配置成NSSA属性才可以。
- 虚链路无法穿越NSSA





配置命令：

```
[AR4]ospf 1
[AR4-ospf-1]area 1
[AR4-ospf-1-area-0.0.0.1]NSSA 配置NSSA区域
[AR4-ospf-1-area-0.0.0.1]NSSA no-summary 配置成Totally NSSA区域
```



## 4.5 区域分割及解决方案

OSPF对于区域的分割有着明确规定：1、其他区域必须围绕骨干区域；2、骨干区域有且只有一个，即不能分割；3、所有非骨干区域间的路由及流量互访，必须经过骨干区域。

因为所有普通区域都要连接着骨干区域，那么就形成了一张星型TOPO图，骨干区域就是中心。

### 4.5.1 普通区域分割

普通区域如果出现分割或断裂而成为两个独立区域，这种情况下，路由是可以正常在区域间传递且全网可达的。

TOPO图我就不给出了，就是普通区域被分割。

因为骨干区域在区域间传递路由，且携带100.1.1.0/24的LSA3上没有起源区域号的标识，经骨干区域进入Area1 符合区域结构设计。

说明：

- Vlink是用于连接分割的骨干区域，不能用于普通区域被分割的情况。
- GRE隧道方能可以适用于任何场景，但易出现环路或次优路径，且GRE隧道具备承载数据的能力，会使得区域设计复杂。同时GRE因封装解封装会导致开销较大，加重边界设备负荷。

### 4.5.2 骨干区域分割

骨干区域分割才是分割中的重点。如果骨干区域被分割，可以采用Vlink虚链路或者GRE来处理，以下是解决办法

### 4.5.3 GRE处理分割

和Vlink一样，双方建立GRE Tunnel即可，但我懒得给出了。





## 4.6 Vlink解决方案

Vlink被看作骨干区域的P2P链路，其配置在两个ABR间。

- Vlink在两个ARB间创建属于骨干区域的**单播邻居关系**。穿过区域1，其单播地址是根据区域1中的R11和R12的Router LSA计算得出的。Router LSA中用于描述拓扑的Link中，Link Data是路由器自身接口的IP地址，这个IP地址也就是Vlink所使用的单播地址。



![4.6.1](https://s3.ax1x.com/2021/01/26/sjML28.md.png)



上面说了那么多，意思就是，虚链路之间是单播邻居关系，那么你就要指定单播邻居，这个单播的地址就是对端（AR12）的Router-ID地址，AR11和AR12会交互HELLO。

我在AR11和AR12之间配置了Vlink，建立成功之后AR10能够学习到AR13的环回口地址，虚链路是配置在Area 1中的，那么配置了Vlink之后的Area 1，就称之为Transir Area，并且Transir Area不能被设置为Stub区域或NSSA区域。

配置命令：

```
[AR11]ospf 1
[AR11-ospf-1]area 1
[AR11-ospf-1-area-0.0.0.1]Vlink-peer 192.168.1.2 (AR12的R ID)
```



---

经过虚链路之后的拓朴图，就是原本的AR10和AR11，那么AR11和AR12做了虚链路之后，扩大了骨干区域，就从原来的淡红色骨干区域，变成了大红色的圈圈，里面的都是骨干区域了。

![4.6.3](https://s3.ax1x.com/2021/01/26/sjMq8f.md.png)

**说明：**这里AR12连接AR13应该是区域2，标识错误了

### 4.6.1 Vlink应用场景

Vlink的应用场景依次如下：

1、连接断开的骨干区域

参考上图

2、连接断开的普通区域

![4.6.2](https://s3.ax1x.com/2021/01/26/sjMjKg.md.jpg)

区域1做了虚链路之后，就相当于是，AR11的G0/0/0（这个口是区域0）在了AR12身上，在外人看来，AR10~AR12就是一个大的区域0，那么AR13 也就是连接到了骨干区域。



### 4.6.2 Vlink及接口和区域认证

![4.6.3](https://s3.ax1x.com/2021/01/26/sjMq8f.md.png)

**1、接口认证**

接口认证没啥好说的，和Vlink没太大关系。

**2、区域认证**

如果区域0做了区域认证的情况之下（AR10和AR11都配置），那么虚链路是不会UP的，因为虚链路如果要成立，那么AR12也就是区域0中的设备了，所以**AR12**也要在区域0中，做区域认证，配置相同的密钥，才可以让虚链路起来。要注意：Vlink属于区域0

### 4.6.3 Vlink特性

- Vlink上可传递LSA 1/2/3/4类型的LSA，其他类型不传递。
- Vlink属于骨干区域，其链路成本为Transit Area内两个ABR节点间的最优路径成本。
- Vlink有正常的邻居关系，周期性发送HELLO及LSA刷新，如果连续失去4个HELLO报文，则Vlink邻居Down（这和直连链路上判断邻居失效的方法一致。）若ABR物理直连段开或二者邻居断开，都会导致Vlink 立即中断。

- Vlink仅用来传递LSA，并不传递数据。区域间数据传递要经过Transit Area内的最优路径，这个路径由ABR根据Transit Area中的LSA 3计算决定，ABR先通过Vlink了解到骨干区域中的网络，在根据Transit区域中的对相应网络的通告LSA3，确认访问骨干区域中该网络的途径。

- Vlink的配置命令很简单，双方ABR指定对端R-ID地址即可，Vlink**仅根据**Transit Are内ABR产生的Router LSA来决定。如果在Router LSA中无法找到可用IP地址，则Vlink无法建立；或如果找到多个IP地址，则成本最小的将是目标IP，如果负载分担的话，选择随意或第一个地址。

- Vlink邻居建立完成后，R12也变成了连接Area 0的ABR设备，R11和R12会在其Area 0中的Router LSAA中添加Type4类型的Link。

  

![4.6.2](https://s3.ax1x.com/2021/01/26/sjMjKg.md.jpg)





在R11中的LSDB情况如下，上面说的Type 4类，在抓包软件中，抓取出来了。

```
* Link ID：3.3.3.3     #Link ID内容是Vlink对端路由器的Router ID
  Data   ：10.1.23.2   #Link Data内容是自身的Vlink IP
  Link Type：Virtual
  Metric ：1           #Transit Area 内到对方 ABR 的最优路径成本
```
![4.6.4](https://s3.ax1x.com/2021/01/26/sjMbPP.md.png)

----

### 4.6.4 Vlink的不足

Vlink使Transit Area无法对 骨干区域聚合。

![OSPF_Vlink](https://s3.ax1x.com/2021/01/26/sjQpan.md.png)

```
AR2上面做了聚合，AR4上面也做了聚合，AR3会收到R2和R4通告的聚合路由，所以R3上10.0.0.0/8指向R2，10.1.0.0/16指向R4，若R3收到访问10.1.1.1的路由，将会通过R4，R4上有Vlink，当路由表中有10.1.1.0/24 2.0/24 3.0/24 的area 0路由，指向R3，也就将流量发给R3，R4将流量发给R3，R3将流量发给R3，以此循环。
若vitrual-Link不存在，R4不是ABR,也就不能执行聚合，仅R2执行聚合，路由环路则不会发生。
```







### 4.6.5 Vlink的Q&A

Q：为什么Vlink上可传递LSA 1/2/3/4，但五类不是属于 -可以泛洪整个路由域的吗？如果传播他，岂不是可以让网络都通信了，还不用有Vlink存在。

A：首先要清楚Vlink的存在是为了解决什么问题。Vlink是因为区域分割而存在，区域分割是为了保证泛洪时不引起大规模的更新，和使得 LSDB中储蓄的LSA数量，大大减少。首先你提出的这个问题，你要清楚，ABR才能转发3类LSA ，要注意是真ABR才可以转发。



# 5、LSA 4&5

## 5.1 LSA4 Sum ASBR

LSA4(ABR Summary)像LSA3类一样，均是由ABR产生的、**并在Area内泛洪**的一类LSA。LSA4和3类采用相同的报文格式，区别是Type子域为4，Link State ID字域是ASBR路由器的RID，**LSA4的内容是ASBR到ABR的成本。告诉其他区域ABSR所在位置。由ABR通告。**

```
Type	:Sum-ABSR       #Type 4
Ls id	:1.1.1.1		#ASBR的R-ID
Adv tr  :6.6.6.6		#ABR
LS age  :1683			LS老化时间
Len		:28
Options :E				#仅E-bit置位，具体可以看 1.6.4 Options
seq#	:800000001		
chksum	:0x5cb3
Tos 0 metric:48			#ABR达到ASBR的成本
```









## 5.2 LSA5 External

五类 External LSA，作用是通告其他引入进OSPF协议的其他协议路由。这些外部路由靠LSA 5将其泛洪到OSPF路由域。

```
  Type      : External
  Ls id     : 192.168.1.0 #Link State ID，五类中表明路由前缀
  Adv rtr   : 2.2.2.2  #通告此LSA的路由器R-ID
  Ls age    : 39 
  Len       : 36 
  Options   :  E  
  seq#      : 80000001 
  chksum    : 0x658
  Net mask  : 255.255.255.0 
  TOS 0  Metric: 1 
  E type    : 2 可以是1或2，默认2，区别在于，2类仅考虑外部路由成本。1考虑的是内外成本之和。这在选路也有差别，可以看X.X
  Forwarding Address : 0.0.0.0  FA地址可以全0，也可非0，如果全0，则访问外部网络的报文转发给ASBR，如果非0，报文转发给该地址
  Tag       : 1 
  Priority  : Low
```

五类路由仅是通告外部引入的路由，LSA5类能够泛洪到所有区域（除了Stub和NSSA），泛洪器间仅Age会增加，其他没变化。

LSA5的作用除了向路由域中的路由器通告外部路由外，还告知其他路由器如何访问该外部路由，也就是通过FA地址。根据五类中的FA地址，来决定他访问外部路由，是找ASBR还是找FA地址。如果FA地址存在（非全0）那么就去转发给该FA地址，如果不存在就去找ABRR。

## 5.3 LSA 五类Forwarding-Address 

FA地址，转发地址就是，仅出现于五类和七类中，它是数据包访问外部网络时，在数据报文离开OSPF路由域时必须经过的设备地址。

注：七类的FA地址，在下个，本小节仅包含五类的FA作用。

LSA5携带外部路由，外部路由不仅要看选路来加入路由表中，还要根据FA地址是否可达。如果FA不可达，则五类所通告的外部路由不进入路由表。（如果FA不可达，那你进入了路由表，也没有任何意义。）

如果FA=0，LSA5要判断如何达到ASBR，继而决定该外部路由能否进入路由表。如果ASBR在其他区域，还要依靠着四类来决定如何到达ASBR。如果ASBR在当前区域，则依赖1/2 LSA计算到ASBR路径即可。

如果ASBR上的接口满足如下条件，则ASBR上外部路由的下一跳地址就是该外部路由LSA5的FA地址，否则FA为0。

1、该外部路由的Next-Hop所在网段的接口，要发布到OSPF中。

2、该外部路由的Next-Hop所在网段的接口没有被设置成Silent接口

3、Next-Hop所在网段的接口，网络类型不能是点到点和点到多点。



只要Display ospf routing能够看到FA地址所对应的路由，则：

- 该外部路由能进入路由表；
- 访问该外部网络得数据将根据FA路由来转发；
- 当前路由器在OSPF路由域是根据该FA路由计算出来的；
- FA地址所对应路由一定是OPSF区域内的（IA Intra-Area）或区域间Inter Area路由，FA路由不能是其他外部路由，LS5不会靠OSPF外部路由和非OSPF协议路由来决定FA地址是否可达的。

总结：FA为0，访问外部路由的数据包转发给给ABSR，为非0，则转发给FA地址。

☢LSA5类中的FA决定外部路由能否进路由表，及转发路径。

☢五类中FA内容:

- - 如果FA=0，区域内根据 LSA 1/2计算路由，**区域外根据LSA 4计算路由**
  - 如果FA≠0，区域内根据 LSA 1/2计算路由，**区域外根据LSA 3计算路由。**



## 5.4 五类泛洪与FA防环

**LSA 5泛洪**

五类可以在区域间泛洪，而三、四类仅区域内泛洪。（3，4可以被属于某个区域，但五类不行）

在骨干被分割，或普通区域未连接骨干的情况下，五类依旧可以不经过Vitrual Link，直接经Transit区域流入其他区域。这与1/2/3/4需要经Vitrual传递到其他区域不同，这也是和五类的泛洪范围有关。

如图：区域1-----区域0------区域3-----区域2。

LSA5类在没有Vlink的情况下，区域1引入的外部路由可以进入区域2，但无法进入路由表（FA地址不可达）

如果FA地址=0，则依赖四类，如果≠0，则依赖三类来计算路由，但由于区域分割，3和4都不能进入区域2.所以无法进入路由表







# 6、NSSA区域及LSA 7

我觉得NSSA区域中，你域内传递（域内就传递1/2/3/7，如果是变种，3类都不会传递），引入了外部路由之后，就会在NSSA域内传递七类，ABR设备将其进行7/5，然后再以五类的形式发送出去。
两个重点：七类中FA地址及7/5翻译
首先是FA地址解释

**注：**虚链路无法穿越NSSA区域

## 6.1 NSSA区域

NSSA区域，也就是Stub区域的变种，算是Stub的Pro升级版。

NSSA（Not So Stubby SArea）是一类特殊的区域，区别于Stub区域，可以在NSSA中部署ASBR，并引入外部路由，不需要经过骨干区域来访问外部目标网络。

“OSPF规定Stub区域是不能引入外部路由的，这样可以避免大量外部路由对Stub区域路由器带宽和存储资源的消耗。对于既需要引入外部路由，但又要避免外部路由带来资源消耗的场景，Stub区域就不再满足需求了，因此产生了NSSA区域。”

|               | Stub                       | To St                    | NSSA                                        | To NS                      |
| ------------- | -------------------------- | ------------------------ | ------------------------------------------- | -------------------------- |
| 区域中LSA类型 | LSA1/2/3 ABR产生3类0.0.0.0 | 1/2类，ABR产生3类0.0.0.0 | 1/2/3/7， A(S)BR产生LSA 7(0.0.0.0)          | 1/2/7 A(S)BR产生7类0.0.0.0 |
| ABR/ASBR      | 区域内不允许ASBR           | 同STUB                   | 区域内允许部署ASBR，边界设备即使ABR也是ASBR | 同NSSA                     |
| 配置          | area stub                  | area stub no-sum         | area nssa                                   | area nssa no-sum           |

**注意：**Hello报文中，Stub区域的E-bit 不置位（就没有了）异变情况也一样。NSSA区域仅N-Bit置位。E-bit没置位的，是不会接受E-bit值位的Hello包的，一定要E比特值位相同的邻居，才会建立邻居关系，NSSA就是N比特置位，才会建立邻居。

只要是变种，就没有三类。

普通区域产生缺省，通过default-rout命令后，产生五类ASE缺省下发。Stub和变种Stub区域是 边界ABR给Stub域内发三类缺省。NSSA是给域内发七类缺省，完全NSSA，再发送七类缺省的情况下，还会发送三类缺省。









## 6.2 NSSA ABR=ASBR

强调一下啊，只要你**始发**了五类，五类是外部路由然后向内部通告的LSA。只要你**始发**了五类，你就算是ASBR了。此为前提

NSSA区域其域边界设备是ABR，同时也是ASBR（边界设备会做七转五，发了五类，他就是ASBR）华为的NSSA默认向NSSA区域内泛洪七类默认路由

NSSA区域边界ABR特性，
- 七类（P置位）后经过ABR 7/5，产生五类泛洪到其他其于

- 默认情况下，会向NSSA区域通告七类默认（如果是变种，还会通告3类默认）

  

七类的特性和作用
- 七类是为了支持NSSA区域而新增的，用于通告引入的外部路由（很像五类，但是只能在NSSA域内通告的特殊“五类”）
- 七类由域边界设备产生，仅域内扩散泛洪。
- NSSA域边界设备均会向NSSA通告七类的默认路由。
- 七类的FA地址一定要是非0，用于区域间选路（选路记得看7.1）

## 6.3 NSSA FA地址及七转五翻译

需要强调的是，七类和五类的FA地址内容有所差别，具体如下：
五类的FA地址可以是0和非0两种情况。（0就看ASBR地址，非0就看非0地址）
七类的FA：
  七类的FA地址=0，是不会被通告到骨干区域的（也就是并不会被ABR设备进行7/5）

FA≠0的情况：
NSSA中，ASBR引入的外部路由，除上面特例外，都是≠0，五类FA的规则，同样使用于七类FA



如果满足规则，则FA地址是ASBR上外部路由的下一跳地址。
如果不满足规则，则FA≠0，优选换回，无则物理（一定要是宣告进了OSPF进程的，接口值，并不是IP越大越优 环回口0大于1 这种，无论你接口IP）

```
规则：
1、该外部路由的Next-Hop所在网段的接口，要发布到OSPF中。
2、该外部路由的Next-Hop所在网段的接口没有被设置成Silent接口
3、Next-Hop所在网段的接口，网络类型不能是点到点和点到多点。
```







**七类地址的区别**

七类和五类，可以在LSDB中看一下，大体都相同（相同的格式，包括外部路由及掩码，FA，Cost-Type及Cost）

不同之处在于：

- 七类仅在NSSA区域内泛洪；
- 七类的FA为非0；如果为0，则不会被ABR转换成五类。或翻译成五类
- 外部路由在NSSA域中使用七类传递，在其他区域五类传递，ABR负责七转五。
- P位用于告知翻译路由器，该条七类是否需要翻译；只有P置位，并且FA地址不为0的七类才能被转化为五类。
- 缺省情况下，7/5翻译由NSSA区域内ABR中R-ID最大的来做。
- 若在ABR设备上引入外部路由，产生的七类不会置P-bit，所以也不会被通告仅骨干区域。



当NSSA区域中，存在多个ABR时，自动由拥有最大R-ID的路由器来进行七转五的转换。也可以通过在ABR上配置transl参数，转换器可手工存在多个。







```
  Type      : NSSA
  Ls id     : 192.168.1.0
  Adv rtr   : 1.1.1.1  
  Ls age    : 495 
  Len       : 36 
  Options   :  NP   N位表示NSSA，P位告知边界ABR要做7/5转换
  seq#      : 80000001 
  chksum    : 0xdf76
  Net mask  : 255.255.255.0 
  TOS 0  Metric: 1 
  E type    : 2
  Forwarding Address : 1.1.1.1 
  Tag       : 1 
  Priority  : Low
```







# 7、选路规则及路由控制

## 7.1 选路规则

OSPF有RFC 1583和RFC2328两种路由选路规则，华为设备默认使用1583选路规则，如果域内有设备使用RFC2328选录规则，使用命令`undo rfc 1583 compatible`，关闭RFC1583兼容功能，使其使用RFC2328定义的选路规则，以保证全网OSPF设备规则的一致性。RFC1583和RFC2328的路由计算规则主要区别在于，计算外部路由时的不一致。如果网络中设备使用不同的计算规则可能会导致路由环路。

	为了解决这两种规则所带来的问题，RF2328中提出了RFC 1583兼容特性，即运行OSPF路由器使用RFC1583兼容规则，进行路由计算。

 **RFC1583兼容性**

1583兼容性主要是指路由器对收到的LSA5如何计算路由，如何在多条外部路由间选择最佳路由。选路规则如下：

1. OSPF区域内路由优于区域间；1类2类大于3类
2. OSPF的域间路由优于外部路由；三类大于五类
3. OSPF外部路由中Metric-Type1 大于Type2类型路由；
4. 同为Type 1的外部路由中，优选内部成本和外部成本之和后成本最小的路由，如果成本一样，则负载分担。
5. 同为Type 2的外部路由中，优选外部成本开销小的路由；如果成本一致，则优选内部成本小的路由，否则负载分担。

第四条规则就是说，Type1类型，计算内外部成本之和最小的。成本一样则负载分担。

第五条规则是说，Type2类型外部路由，先比外部，选最小的，外部一样，就选内部成本最小的，内部一样，就负载分担。







## 7.2 矢量特性

OSFP在区域内不具备矢量特性，仅在边界ABR或ASBR设备上具备“矢量“特性。矢量特性是指在边界路由器上，**LSA的产生依赖路由表里相应路由是否存在**，如果路由不存在，则不会产生相应的LSA。（可以通过过滤ABR或ASBR路由表里的路由，就可以控制向其它区域路由的通告了。）

OSPF可以对自身的路由表进行控制，但只能通过配置，将自身的路由表有或者没有，不能通过此，或者说是通过对邻居路由，不发送路由，来做到

OSPF域内路由器不能够做到对域内其他路由器设备的路由控制，仅能通过配置对自身OSPF路由进行过滤，这是由于OSPF域内路由器并不具有矢量特性（域内发布的路由就是1/2，1/2是要组合使用的，怎么能和矢量特性一概而论呢？！）OPSF在域内不具备矢量特性，但也仅在边界ABR或ASBR设备上具备“矢量”特性。

注：矢量特性是指在边界路由器上，LSA的产生依赖路由表中相应路由是否存在，如果路由不存在，则不会产生相应的LSA。



疑点1、ARB设备上，能够做的话，他是产生3/5类能做过滤，还是ABR上的1/2也可以？



## 7.3 路由控制



```
filter-policy X import 在任意路由器上，对进入路由表的的路由做过滤
-----这个就是任意设备都可以做，然后进行对进入我路由表做过滤，但我LSDB信息库，还是域内都泛洪同步的，我本机过滤了路由，域内其他设备，照样有。

filter-policy X export 在ABSR上，对引入的路由做过滤
-----一定是ASBR上，我在NSSA区域的ABR，我想着他也是做7/5，也算ASBR啊，但一定是做引入的那台设备上，做了之后就有用。

filter X export ABR上，对离开的Area的LSA 3类做过滤
只能对三类做，但ASBR上，我估计也可以
filter X import ABR上，对进入该Area的LSA 3类做过滤
filter-LSA-out 接口夏， 对泛洪的全部LSA或3/5/7做过滤
```

acl 2000

rule 5 deny X.X.X.X，引入的控制，是看ACL的per 或者deny的哦。

| 命令                                       | 说明                                     |
| ------------------------------------------ | ---------------------------------------- |
| 接口下 filter-policy [X] import            | 在任意路由器上，对进入路由表的路由做过滤 |
| 接口下 filter-policy [X] export            | 在ASBR上，对引入的路由做过滤             |
| 区域下 filter [X] export                   | 在ABR上，对离开该区域的LSA 3做过滤       |
| 区域下 filter [X] export                   | 在ABR上，对进入该区域的LSA 3做过滤       |
| 接口下 filter-LSA-out                      | 对**泛洪**的全部LSA或LAS 3/5/7做过滤     |
| OSPF进程下 Filter-LSA-out peer             | 指定对邻居过滤，P2MP网络中用             |
| 区域下 ARB-Sum 路由 掩码 not-advertise     | ABR上对聚合路由范围内的所有明细路由过滤  |
| 进程下 ASBR-summary 路由 掩码not-advertise | ASBR上对聚合路由范围你的所有明细路由过滤 |

[X] 这个代表着 可以接route-policy，或者ACL，或者前缀列表。



ABR-Sum过滤，只能在3类起源处配置。ASBR-SUM同理



## 7.4 路由聚合

路由聚合只能发生在矢量行为边界设备ABR及ASBR上。

- 抑制明细路由，并向外通告聚合路由，还能够减少路由表大小，降低更新大小，系统消耗降低；

- 至少有一条明细路由存在，路由器才能通告聚合路由，否则不会产生聚合路由；

- 聚合路由范围内的明细路由，出现路由抖动等变化，不会影响已通告的汇聚路由 

  缺点：设计不当，容易出环

注：华为设备在执行路由聚合时，并不会自动在路由表中添加一条避免环路的指向NULL0的接口路由。

聚合路由的cost缺省时，会采用被聚合路由中最大的开销值来作为聚合路由的开销。当为type1时，取最大聚合路由的COST，当为Type2时，取

聚合路由的配置我就懒得说了，我就说一些要注意的点吧。

- 如果本地设备是ASBR且处于普通区域中，本地设备对引入的聚合地址范围内的所有五类LSA进行路由聚合。
- 如果本地设备是ASBR且处于NSSA中，本地设备对引入的聚合地址范围内的所有五类五类和七类进行路由聚合
- 如果本地设备是ABR又是ASBR又处于NSSA中，本地设备对引入的聚合地址范围内的所有5，7外，还会对7转5的LSA也进行路由聚合。

## 7.5 默认路由

默认路由很简单，你OSPF做默认路由时，仅当路由表中存在默认路由条目时，才会产生默认路由

三类默认大于五类或七类默认。

自动产生，通过命令做的，那个就是三类默认。





# 8、OSPFv3 （待补充）待添加一个v2和v3的区别、

华为设备OSPFv3仅支持IPv6地址簇

## 8.1 OSPFv2和v3相同与不同点

相同点：

- 网络与接口类型
- 接口和邻居状态机
- LSDB
- 泛洪机制
- 相同的HELLO,DBD,LSR,LSU,LSAck报文
- 算法及路由计算过程

不同：v3工作于v6之上，v2工作v4上，其他细节如下。

### 8.1.1 OSPFv3基于链路，而不是网段

OSFPv3运行于IPv6协议上，IPv6是基于链路而不是网段的，既不论接口是否配置ULA/GUA（唯一本地/全局单播）也不论路由器间接口地址是否处于同一个网段，只要批次在同一个链路上，即可建立OSPF邻居关系。





### 8.1.2 OSPFv3利用**IPv6的链路本地地址**

OSPFv3使用链路本地地址Link-Local来维持邻居，同步LSDB。链路上的报文除了Vlink外的所有OSFPv3接口都使用链路本地地址作为报文源地址。

**About 链路本地地址**

- IPv6的链路本地地址用于在同一链路上发现邻居及自动配置等；
- 运行IPv6的路由器不转发目的地址为链路本地地址的IPv6报文，此类报文只在本地链路有效；
- 链路本地单播地址的前缀为FE80::/10。



### 8.1.3 OSPFv3协议报文移除了“协议地址”语义

v2的1/2类包含了太多地址信息，如一类中的Link Data是设备本地接口的IPv4地址，LinkID是DR的接口IP地址或邻居的RID等。如果OSPFv3也采用相同的方式，IPv6凭借其庞大的地址大小（128位），如果要包含地址信息，报文会变得十分庞大，将会过多的占用LSA空间，而且也不利于OSPFv3的拓展，所以OSPFv3在设计之处，就从LSA中“移除”对协议地址的依赖性。

```
此处留空，v2和v3的 1/2类对比
```

经过上述对比，可知OSPFv3 LSA1/2中用于表述拓扑时，用二元组RID,接口ID，来取代OSPFv2中针对对方节点的表示。LSA1/2没有采用任何协议地址，能够使得其拓扑与协议地址分离，未来如果有新的协议地址存在，那么也能够兼容。

需要注意的是OSPFv3下的Vlink场景，非直连的邻居需要靠全局单播ULA地址来标识。IPv6全局地址仅出现在Vlink接口及报文的转发场合。

链路间的泛洪范围

OSFPv3添加了链路间的泛洪范围，新的八类Link LSA类型仅可以在邻居间通告，其LSA不会被泛洪到其他链路。八类所承载的内容仅在直连的邻居间有用，用于通告该Link上的前缀及Link-local地址。

5.OSFPv3支持单链路多进程

什么是单链路多进程，OSPFv3在报文头添加了一个新的字域：Instance ID，它是定义在接口的标识OSPF实例的0~255的数。OSPFv2下，一个接口上只能有一个OSPF实例运行，现在可以让一个接口同时属于（运行）多个实例，彼此通过实例ID区分。

注：如果OSPFv3收到实例不相同的Hello报文，则忽略，邻居关系无法建立。

8.1.6 OSPFv3移除了所有认证字段

OSPFv3移除了接口和区域认证，原因是OSPFv3可直接使用IPv6扩展报文头的认证及安全机制，不需要再重复提供认证，使用协议时只需要关注协议本身即可，降低协议复杂性。

8.1.7 OSPFv3只通过R ID来标识邻居

OSPFv3只通过R ID来标识邻居，这样即使没配置v6全局地址，或是IPv6全局地址配置都不在同一网段，OSPFv3的邻居仍可以建立起来。OSPFv3中RID和OSPFv2中一样，是32位数，v3中可手工配置RID

8.1.8 新增两种LSA

Link LSA八类和Intra-Area-PrefixLSA九类

八类用于宣告链路上的Link-Local地址及IPv6 Prefix地址，其仅在本地链路上泛洪。

Intra-Area-Prefix LSA用于向其他路由器宣告本路由器或本网络（广播及NMBA）的IPv6全局地址信息，在区域内泛洪。





3.8.3.1 类型分类

| Type | OSPFv2               | LS Type | OSPFv3                |
| ---- | -------------------- | ------- | --------------------- |
| 1    | Router LSA           | 0x2001  | 同v2相同              |
| 2    | Network LSA          | 0x2002  | 同v2相同              |
| 3    | Network Summary      | 0x2003  | Inter-Area Prefix LSA |
| 4    | ASBR Summary         | 0x2004  | Inter-Area Router LSA |
| 5    | AS-External LSA      | 0x2005  | 同v2相同              |
| 6    | Group Membership LSA | 0x2006  | 同v2相同              |
| 7    | NSSA External        | 0x2007  | Type-7 LSA            |
|      |                      | 0x2008  | Link LSA              |
|      |                      | 0x2009  | Intra-Area Prefix LSA |







# 9、OSPF 百问

# 10、补充知识点

## 10.1 防环与双点双向重分发碰撞

## 10.2 防环与MPLS 跨域VPN 碰撞

## 10.3 OSPF和ISIS

## 10.4 LDP和IGP联动 OSPFGR

## 10.5 OSPF的Sham-link

Sham-Link，伪链路

伪链路和正常的OSPF 链路一样，有自己的OSPF接口，可以发送OSPF 协议报文，建立邻居，发送LSA ，当LSA 在伪链路中进行泛洪时，所有的OSPF 路由类型不会改变。

1）通过MP-IBGP携带私网路由的方式，只是传递路由，到达对端PE后的还原工作也只是尽力而为式的引入原有OSPF 路由信息，并不能真正使OSPF 的拓扑信息得到沟通。通过伪链路在建立一条OSPF 链路，从而使各个站点内的OSPF 实例能够真正连通，并建立完整的拓扑信息。
2）同一VPN内的不同站点通过MPLS 骨干网交互信息，但是这些VPN站点内部又连接一条链路，其目的是在MPLS 骨干网无法使用时，VPN站点间仍然可以通过该链路通信，这种链路称为“后门链路”。如果VPN用户的两个站点同属于同一个OSPF 区域，且这两个站点间又连接一条“后门链路”，那么两个站点内的路由即通过MPLS 骨干网交互，也通过“后门链路”交互，由于通过MPLS 骨干网交互后的路由**为域间路由**，而通过“后门链路”交互后的路由为域内路由，显然后门链路所通告的域内路由优于MPLS 骨干网通告的域间路由，因而这两个站点内的路由转发会优先走后门链路，这不符合 VPN用户连接“后门链路”的意图，因此这种应用也需要使用伪链路。


